{% extends "layout.html" %}

{% block title %}Account Configuration - DhanBot{% endblock %}

{% block styles %}
  {{ super() }}
  <link rel="stylesheet" href="{{ url_for('static', filename='addaccount.css') }}">
{% endblock %}

{% block content %}
<div class="account-config-page">
    <div class="background-shapes">
        <div class="shape shape1"></div>
        <div class="shape shape2"></div>
    </div>

    <div class="account-config-container container">
        <div class="page-header">
            <div>
                <h1 class="page-title">Account Configuration</h1>
                <div class="breadcrumb">
                    <span>Dashboard</span>
                    <span>•</span>
                    <span class="breadcrumb-current">Account Configuration</span>
                </div>
            </div>
            <button id="add-account-btn" class="btn btn-primary" type="button">
                <svg class="icon icon-sm" viewBox="0 0 24 24" aria-hidden="true">
                    <line x1="12" y1="5" x2="12" y2="19"></line>
                    <line x1="5" y1="12" x2="19" y2="12"></line>
                </svg>
                <span id="add-btn-text">Add New Account</span>
            </button>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-content">
                    <div class="stat-icon stat-icon-primary">
                        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true">
                            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="9" cy="7" r="4"></circle>
                            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                        </svg>
                    </div>
                    <div>
                        <p class="stat-label">Total capacity</p>
                        <p class="stat-value" id="total-capacity">0</p>
                    </div>
                </div>
            </div>

            <div class="stat-card">
                <div class="stat-content">
                    <div class="stat-icon stat-icon-success">
                        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true">
                            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="9" cy="7" r="4"></circle>
                            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                        </svg>
                    </div>
                    <div>
                        <p class="stat-label">Master capacity</p>
                        <p class="stat-value" id="master-accounts-count">0</p>
                    </div>
                </div>
            </div>

            <div class="stat-card">
                <div class="stat-content">
                    <div class="stat-icon stat-icon-warning">
                        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true">
                            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="9" cy="7" r="4"></circle>
                            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                        </svg>
                    </div>
                    <div>
                        <p class="stat-label">Children capacity</p>
                        <p class="stat-value" id="child-accounts-count">0</p>
                    </div>
                </div>
            </div>

            <div class="stat-card">
                <div class="stat-content">
                    <div class="stat-icon stat-icon-danger">
                        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true">
                            <path d="M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z"></path>
                        </svg>
                    </div>
                    <div>
                        <p class="stat-label">Plan name</p>
                        <p class="stat-value" id="current-plan">—</p>
                    </div>
                </div>
            </div>

            <div class="stat-card">
                <div class="stat-content">
                    <div class="stat-icon stat-icon-muted">
                        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true">
                            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                            <line x1="16" y1="2" x2="16" y2="6"></line>
                            <line x1="8" y1="2" x2="8" y2="6"></line>
                            <line x1="3" y1="10" x2="21" y2="10"></line>
                        </svg>
                    </div>
                    <div>
                        <p class="stat-label">Validity</p>
                        <p class="stat-value" id="plan-validity">—</p>
                    </div>
                </div>
            </div>
        </div>

        <div id="add-account-section" class="form-section animate-in" style="display:none;">
            <h2 class="form-title">Add/Edit Account Details</h2>
            <p class="form-description">Select your broker to configure account credentials.</p>

            <div class="broker-search">
                <svg class="icon icon-sm search-icon" viewBox="0 0 24 24" aria-hidden="true">
                    <circle cx="11" cy="11" r="8"></circle>
                    <path d="m21 21-4.35-4.35"></path>
                </svg>
                <input type="text" class="form-input search-input" id="broker-search" placeholder="Search broker...">
            </div>

            <div class="broker-grid broker-scroll" id="broker-grid">
                <p class="broker-empty">Search or select a broker to begin.</p>
            </div>

            <form id="broker-credentials-form">
                <div id="broker-fields" class="form-grid">
                    <p class="form-placeholder">Please select a broker above to view configuration fields.</p>
                </div>
                <div id="cred-check-result" class="form-feedback"></div>
                <div class="form-actions">
                    <button type="button" class="btn btn-outline" id="cancel-add-account-btn">Close</button>
                    <button type="submit" class="btn btn-primary" id="submit-account-btn" style="display:none;">Add Account</button>
                </div>
            </form>
        </div>

        <div class="card">
            <div class="tabs" id="status-tabs">
                <button class="tab status-tab active" type="button" data-status="all">
                    All
                    <span class="badge badge-secondary" id="tab-count-all">0</span>
                </button>
                <button class="tab status-tab" type="button" data-status="success">
                    Success
                    <span class="badge badge-success" id="tab-count-success">0</span>
                </button>
                <button class="tab status-tab" type="button" data-status="failed">
                    Failed
                    <span class="badge badge-danger" id="tab-count-failed">0</span>
                </button>
            </div>

            <div class="toolbar">
                <div class="toolbar-left">
                    <select id="broker-filter">
                        <option value="">All Brokers</option>
                    </select>
                    <div class="search-wrapper">
                        <svg class="icon icon-sm search-icon" viewBox="0 0 24 24" aria-hidden="true">
                            <circle cx="11" cy="11" r="8"></circle>
                            <path d="m21 21-4.35-4.35"></path>
                        </svg>
                        <input type="text" class="form-input search-input" id="account-search" placeholder="Search...">
                    </div>
                </div>

                <div class="dropdown" id="more-dropdown">
                    <button class="btn btn-icon btn-ghost" type="button" data-dropdown-toggle="more-dropdown" aria-haspopup="true" aria-expanded="false">
                        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true">
                            <circle cx="12" cy="12" r="1"></circle>
                            <circle cx="12" cy="5" r="1"></circle>
                            <circle cx="12" cy="19" r="1"></circle>
                        </svg>
                    </button>
                    <div class="dropdown-menu" role="menu">
                        <button class="dropdown-item" type="button" data-action="export-accounts">
                            <svg class="icon icon-sm" viewBox="0 0 24 24" aria-hidden="true">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="7 10 12 15 17 10"></polyline>
                                <line x1="12" y1="15" x2="12" y2="3"></line>
                            </svg>
                            Export
                        </button>
                    </div>
                </div>
            </div>

            <div class="table-wrapper">
                <table>
                    <thead>
                        <tr>
                            <th style="width: 48px;">
                                <input type="checkbox" class="checkbox" id="select-all-accounts" aria-label="Select all accounts">
                            </th>
                            <th>Client ID</th>
                            <th class="mobile-hide lg-show">Opening Balance</th>
                            <th>Auto-Login</th>
                            <th class="mobile-hide md-show">Last Login Time</th>
                            <th class="mobile-hide xl-show">Developer URL</th>
                            <th class="mobile-hide xl-show">Static IP</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody id="accounts-table-body"></tbody>
                </table>
            </div>

            <div id="accounts-empty-state" class="empty-state" style="display:none;">
                <svg class="icon icon-sm" viewBox="0 0 24 24" aria-hidden="true">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="12"></line>
                    <circle cx="12" cy="16" r="1"></circle>
                </svg>
                <p>No accounts found matching your criteria.</p>
            </div>

            <div class="table-footer">
                <div class="text-sm text-muted" id="accounts-summary">No accounts to display</div>
                <div class="footer-controls">
                    <div class="footer-group">
                        <span class="text-sm text-muted">Rows per page:</span>
                        <select disabled>
                            <option>10</option>
                            <option>20</option>
                            <option>50</option>
                        </select>
                    </div>
                    <span class="text-sm text-muted" id="accounts-range">0-0 of 0</span>
                    <div class="footer-group">
                        <button class="btn btn-icon btn-ghost" type="button" disabled>
                            <svg class="icon" viewBox="0 0 24 24" aria-hidden="true">
                                <polyline points="15 18 9 12 15 6"></polyline>
                            </svg>
                        </button>
                        <button class="btn btn-icon btn-ghost" type="button" disabled>
                            <svg class="icon" viewBox="0 0 24 24" aria-hidden="true">
                                <polyline points="9 18 15 12 9 6"></polyline>
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
if (!window.pageScripts) window.pageScripts = {};
if (!window.pageScriptStates) window.pageScriptStates = {};

window.pageScripts["Add-Account"] = function() {
  const previousState = window.pageScriptStates["Add-Account"];
  const previousCachedAccounts = previousState && previousState.cachedAccounts;
  const previousCachedAutoLoginResults = previousState && previousState.cachedAutoLoginResults;
  const previousCachedFilters = previousState && previousState.cachedFilters;

  if (previousState && typeof previousState.cleanup === 'function') {
    try {
      previousState.cleanup();
    } catch (error) {
      console.warn('Failed to cleanup previous Add Account state:', error);
    }
  }

  let isActive = true;

  const state = {
    listeners: [],
    abortControllers: [],
    cachedAccounts: previousCachedAccounts
      ? {
          accounts: Array.isArray(previousCachedAccounts.accounts)
            ? JSON.parse(JSON.stringify(previousCachedAccounts.accounts))
            : [],
          signature: previousCachedAccounts.signature || null,
          fetchedAt: previousCachedAccounts.fetchedAt || null
        }
      : null,
    cachedAutoLoginResults: previousCachedAutoLoginResults
      ? JSON.parse(JSON.stringify(previousCachedAutoLoginResults))
      : {},
    cachedFilters: previousCachedFilters
      ? {
          statusFilter: previousCachedFilters.statusFilter || 'all',
          brokerFilter: previousCachedFilters.brokerFilter || '',
          searchFilter: previousCachedFilters.searchFilter || '',
          selectedAccountIds: Array.isArray(previousCachedFilters.selectedAccountIds)
            ? [...previousCachedFilters.selectedAccountIds]
            : []
        }
      : null,
    dhanLoginState:
      previousState && previousState.dhanLoginState
        ? JSON.parse(JSON.stringify(previousState.dhanLoginState))
        : null,
    cleanup() {
      if (!isActive) {
        return;
      }
      isActive = false;
      this.abortControllers.forEach(controller => {
        try {
          controller.abort();
        } catch (err) {
          console.warn('Failed to abort fetch controller:', err);
        }
      });
      this.abortControllers = [];
      this.listeners.forEach(removeListener => {
        try {
          removeListener();
        } catch (err) {
          console.warn('Failed to remove event listener:', err);
        }
      });
      this.listeners = [];
    }
  };

  window.pageScriptStates["Add-Account"] = state;

  let dhanLoginState = state.dhanLoginState
    ? JSON.parse(JSON.stringify(state.dhanLoginState))
    : null;

  function cloneDhanLoginState(value) {
    if (!value || typeof value !== 'object') {
      return null;
    }
    try {
      return JSON.parse(JSON.stringify(value));
    } catch (error) {
      console.warn('Failed to clone Dhan login state:', error);
      return { ...value };
    }
  }

  function persistDhanLoginState() {
    state.dhanLoginState = cloneDhanLoginState(dhanLoginState);
  }

  function clearDhanLoginState() {
    dhanLoginState = null;
    persistDhanLoginState();
  }

  const DHAN_FORM_STORAGE_KEY = 'add-account:dhan-form';
  const DHAN_PENDING_SUBMIT_KEY = 'add-account:dhan-pending-submit';
  const DHAN_STORAGE_TTL_MS = 5 * 60 * 1000; // five minutes
  const DHAN_FORM_FIELDS_TO_STORE = [
    'username',
    'client_id',
    'api_key',
    'api_secret',
    'client_name',
    'email',
    'mobile'
  ];

  let pendingDhanTokenId = null;
  let dhanConsentController = null;

  function safeStorageGet(key) {
    try {
      return window.localStorage ? window.localStorage.getItem(key) : null;
    } catch (error) {
      console.warn('Failed to read storage key', key, error);
      return null;
    }
  }

  function safeStorageSet(key, value) {
    try {
      if (window.localStorage) {
        window.localStorage.setItem(key, value);
      }
    } catch (error) {
      console.warn('Failed to persist storage key', key, error);
    }
  }

  function safeStorageRemove(key) {
    try {
      if (window.localStorage) {
        window.localStorage.removeItem(key);
      }
    } catch (error) {
      console.warn('Failed to remove storage key', key, error);
    }
  }

  function isExpiredTimestamp(savedAt) {
    if (typeof savedAt !== 'number') {
      return true;
    }
    return Date.now() - savedAt > DHAN_STORAGE_TTL_MS;
  }

  function getPersistedDhanForm() {
    const raw = safeStorageGet(DHAN_FORM_STORAGE_KEY);
    if (!raw) {
      return null;
    }
    try {
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== 'object') {
        return null;
      }
      if (isExpiredTimestamp(parsed.savedAt)) {
        safeStorageRemove(DHAN_FORM_STORAGE_KEY);
        return null;
      }
      return parsed;
    } catch (error) {
      console.warn('Failed to parse stored Dhan form snapshot:', error);
      safeStorageRemove(DHAN_FORM_STORAGE_KEY);
      return null;
    }
  }

  function persistDhanFormSnapshot(container) {
    if (!container) {
      return null;
    }
    const values = {};
    DHAN_FORM_FIELDS_TO_STORE.forEach(name => {
      const input = container.querySelector(`input[name="${CSS.escape(name)}"]`);
      if (input && input.value) {
        values[name] = input.value;
      }
    });
    if (Object.keys(values).length === 0) {
      safeStorageRemove(DHAN_FORM_STORAGE_KEY);
      return null;
    }
    const snapshot = {
      values,
      savedAt: Date.now()
    };
    safeStorageSet(DHAN_FORM_STORAGE_KEY, JSON.stringify(snapshot));
    return snapshot;
  }

  function restoreDhanFormSnapshot(container) {
    if (!container) {
      return null;
    }
    const snapshot = getPersistedDhanForm();
    if (!snapshot || !snapshot.values || typeof snapshot.values !== 'object') {
      return null;
    }
    Object.entries(snapshot.values).forEach(([name, value]) => {
      const input = container.querySelector(`input[name="${CSS.escape(name)}"]`);
      if (input && !input.value) {
        input.value = value;
        try {
          input.dispatchEvent(new Event('input', { bubbles: true }));
        } catch (error) {
          console.warn('Failed to dispatch input event for', name, error);
        }
      }
    });
    return snapshot;
  }

  function clearPersistedDhanForm() {
    safeStorageRemove(DHAN_FORM_STORAGE_KEY);
  }

  function markPendingDhanSubmission() {
    const payload = {
      savedAt: Date.now(),
      value: '1'
    };
    safeStorageSet(DHAN_PENDING_SUBMIT_KEY, JSON.stringify(payload));
  }

  function clearPendingDhanSubmission() {
    safeStorageRemove(DHAN_PENDING_SUBMIT_KEY);
  }

  function consumePendingDhanSubmission() {
    const raw = safeStorageGet(DHAN_PENDING_SUBMIT_KEY);
    safeStorageRemove(DHAN_PENDING_SUBMIT_KEY);
    if (!raw) {
      return false;
    }
    try {
      const parsed = JSON.parse(raw);
      if (!parsed || parsed.value !== '1' || isExpiredTimestamp(parsed.savedAt)) {
        return false;
      }
      return true;
    } catch (error) {
      console.warn('Failed to parse pending submission flag:', error);
      return false;
    }
  }

  function cloneAccountsList(accounts) {
    if (!Array.isArray(accounts)) {
      return [];
    }
    try {
      return JSON.parse(JSON.stringify(accounts));
    } catch (error) {
      console.warn('Failed to clone accounts list:', error);
      return Array.from(accounts);
    }
  }

  function computeAccountsSignature(accounts) {
    try {
      return JSON.stringify(Array.isArray(accounts) ? accounts : []);
    } catch (error) {
      console.warn('Failed to compute accounts signature:', error);
      return String(Date.now());
    }
  }

  function createAccountsCache(accounts, signatureOverride) {
    const cloned = cloneAccountsList(accounts);
    return {
      accounts: cloned,
      signature: typeof signatureOverride === 'string'
        ? signatureOverride
        : computeAccountsSignature(cloned),
      fetchedAt: Date.now()
    };
  }

  function cloneAutoLoginResults(results) {
    if (!results || typeof results !== 'object') {
      return {};
    }
    try {
      return JSON.parse(JSON.stringify(results));
    } catch (error) {
      console.warn('Failed to clone auto login results:', error);
      return { ...results };
    }
  }

  function persistAutoLoginState() {
    state.cachedAutoLoginResults = cloneAutoLoginResults(autoLoginResults);
  }

  function persistFiltersAndSelection() {
    state.cachedFilters = {
      statusFilter,
      brokerFilter,
      searchFilter,
      selectedAccountIds: Array.from(selectedAccountIds)
    };
  }

  function restoreFilterUI() {
    document.querySelectorAll('#status-tabs .status-tab').forEach(button => {
      const buttonStatus = button.dataset.status || 'all';
      const isActive = buttonStatus === statusFilter;
      button.classList.toggle('active', isActive);
      if (isActive) {
        button.setAttribute('aria-selected', 'true');
      } else {
        button.removeAttribute('aria-selected');
      }
    });

    const brokerFilterSelect = document.getElementById('broker-filter');
    if (brokerFilterSelect) {
      const availableValues = Array.from(brokerFilterSelect.options).map(option => option.value);
      if (brokerFilter && availableValues.includes(brokerFilter)) {
        brokerFilterSelect.value = brokerFilter;
      } else {
        brokerFilterSelect.value = '';
        if (brokerFilter) {
          brokerFilter = '';
        }
      }
    }

    const accountSearchInput = document.getElementById('account-search');
    if (accountSearchInput) {
      accountSearchInput.value = searchFilter || '';
    }
  }

  function pruneAutoLoginResults() {
    const validIds = new Set(
      allAccounts
        .map(acc => (acc && acc.client_id ? acc.client_id : null))
        .filter(Boolean)
    );
    let removed = false;
    Object.keys(autoLoginResults).forEach(key => {
      if (key && !validIds.has(key)) {
        delete autoLoginResults[key];
        removed = true;
      }
    });
    if (removed) {
      persistAutoLoginState();
    }
  }

  const registerListener = (target, type, handler, options) => {
    if (!target || typeof target.addEventListener !== 'function') {
      return;
    }
    target.addEventListener(type, handler, options);
    state.listeners.push(() => {
      if (target && typeof target.removeEventListener === 'function') {
        target.removeEventListener(type, handler, options);
      }
    });
  };

  const registerAbortController = controller => {
    if (!controller) {
      return () => {};
    }
    state.abortControllers.push(controller);
    return () => {
      state.abortControllers = state.abortControllers.filter(c => c !== controller);
    };
  };

  const brokerIcons = {{ (broker_icons or {}) | tojson }};
  window.brokerIcons = brokerIcons;

  const brokerFields = {
    flattrade: [
      { label: "Flattrade Client ID", name: "client_id", type: "text" },
      { label: "Password", name: "password", type: "password" },
      { label: "API Key", name: "api_key", type: "text" },
      { label: "API Secret", name: "api_secret", type: "password" },
      { label: "TOTP Key", name: "totp_secret", type: "text" },
      { label: "Email Id (optional)", name: "email", type: "text", optional: true },
      { label: "Mobile no (optional)", name: "mobile", type: "text", optional: true }
    ],
    acagarwal: [
      { label: "AC Agarwal Client ID", name: "client_id", type: "text" },
      { label: "API Key", name: "api_key", type: "text" },
      { label: "API Secret", name: "api_secret", type: "password" },
      { label: "Email Id (optional)", name: "email", type: "text", optional: true },
      { label: "Mobile no (optional)", name: "mobile", type: "text", optional: true }
    ],
    motilaloswal: [
      { label: "Motilal Oswal Client ID", name: "client_id", type: "text" },
      { label: "Password", name: "password", type: "password" },
      { label: "API Key", name: "api_key", type: "text" },
      { label: "PAN", name: "pan", type: "text" },
      { label: "TOTP Key", name: "totp_secret", type: "text" },
      { label: "Email Id (optional)", name: "email", type: "text", optional: true },
      { label: "Mobile no (optional)", name: "mobile", type: "text", optional: true }
    ],
    kotakneo: [
      { label: "10 Digit Mobile Number/PAN", name: "client_id", type: "text" },
      { label: "Password", name: "password", type: "password" },
      { label: "API Key", name: "api_key", type: "text" },
      { label: "API Secret", name: "api_secret", type: "password" },
      { label: "MPIN", name: "mpin", type: "password" },
      { label: "Client Name", name: "client_name", type: "text" },
      { label: "Email Id (optional)", name: "email", type: "text", optional: true },
      { label: "Mobile no (optional)", name: "mobile", type: "text", optional: true }
    ],
    tradejini: [
      { label: "Tradejini Client ID", name: "client_id", type: "text" },
      { label: "Password", name: "password", type: "password" },
      { label: "API Key", name: "api_key", type: "text" },
      { label: "API Secret", name: "api_secret", type: "password" },
      { label: "MPIN", name: "mpin", type: "password" },
      { label: "Client Name", name: "client_name", type: "text" },
      { label: "Email Id (optional)", name: "email", type: "text", optional: true },
      { label: "Mobile no (optional)", name: "mobile", type: "text", optional: true }
    ],
    zebu: [
      { label: "Zebu Client ID", name: "client_id", type: "text" },
      { label: "Password", name: "password", type: "password" },
      { label: "API Key", name: "api_key", type: "text" },
      { label: "API Secret", name: "api_secret", type: "password" },
      { label: "MPIN", name: "mpin", type: "password" },
      { label: "Client Name", name: "client_name", type: "text" },
      { label: "Email Id (optional)", name: "email", type: "text", optional: true },
      { label: "Mobile no (optional)", name: "mobile", type: "text", optional: true }
    ],
    enrichmoney: [
      { label: "Enrich Money Client ID", name: "client_id", type: "text" },
      { label: "Password", name: "password", type: "password" },
      { label: "API Key", name: "api_key", type: "text" },
      { label: "API Secret", name: "api_secret", type: "password" },
      { label: "MPIN", name: "mpin", type: "password" },
      { label: "Client Name", name: "client_name", type: "text" },
      { label: "Email Id (optional)", name: "email", type: "text", optional: true },
      { label: "Mobile no (optional)", name: "mobile", type: "text", optional: true }
    ],
    dhan: [
      { label: "Dhan Client ID", name: "client_id", type: "text" },
      { label: "API Key (App ID)", name: "api_key", type: "text", tip: "From Dhan → Profile → Access DhanHQ APIs." },
      { label: "API Secret", name: "api_secret", type: "password" },
     {
        label: "Access Token",
        name: "access_token",
        type: "password",
        optional: true,
        readonly: true,
        autofillOnly: true,
        placeholder: "Auto-filled after completing consent login",
        tip: "Auto-filled after completing the consent login."
      },
      {
        label: "Token Expiry",
        name: "token_expiry",
        type: "text",
        optional: true,
        readonly: true,
        autofillOnly: true,
        placeholder: "Filled from the login response",
        tip: "Auto-filled from the login completion response (ISO timestamp)."
      },
      { label: "Client Name", name: "client_name", type: "text" },
      { label: "Email Id (optional)", name: "email", type: "text", optional: true },
      { label: "Mobile no (optional)", name: "mobile", type: "text", optional: true }
    ],
    finvasia: [
      { label: "Client ID", name: "client_id", type: "text" },
      { label: "Password", name: "password", type: "password" },
      { label: "TOTP Secret", name: "totp_secret", type: "text", tip: "Copy the secret string from Shoonya → Profile → Security → TOTP. Do not enter the 6-digit code." },
      { label: "Vendor Code", name: "vendor_code", type: "text", tip: "From Prism back office → Profile → API Key." },
      { label: "API Key", name: "api_key", type: "text", tip: "API Key/Secret from Prism back office." },
      { label: "IMEI", name: "imei", type: "text", tip: "Use the IMEI registered in Prism." },
      { label: "Email Id (optional)", name: "email", type: "text", optional: true },
      { label: "Mobile no (optional)", name: "mobile", type: "text", optional: true }
    ],
    fyers: [
      { label: "Fyers App ID", name: "client_id", type: "text" },
      { label: "Secret Key", name: "secret_key", type: "password" },
      { label: "Email Id (optional)", name: "email", type: "text", optional: true },
      { label: "Mobile no (optional)", name: "mobile", type: "text", optional: true }
    ],
    groww: [
      { label: "Groww Client ID", name: "client_id", type: "text" },
      { label: "Access Token", name: "access_token", type: "password" },
      { label: "Email Id (optional)", name: "email", type: "text", optional: true },
      { label: "Mobile no (optional)", name: "mobile", type: "text", optional: true }
    ],
    aliceblue: [
      { label: "Alice Blue Client ID", name: "client_id", type: "text" },
      { label: "API Key", name: "api_key", type: "text" },
      { label: "Email Id (optional)", name: "email", type: "text", optional: true },
      { label: "Mobile no (optional)", name: "mobile", type: "text", optional: true }
    ],
    zerodha: [
      { label: "Zerodha Client ID", name: "client_id", type: "text" },
      { label: "Password", name: "password", type: "password" },
      { label: "API Key", name: "api_key", type: "text" },
      { label: "API Secret", name: "api_secret", type: "text" },
      { label: "TOTP Key", name: "totp_secret", type: "text" },
      { label: "Email Id (optional)", name: "email", type: "text", optional: true },
      { label: "Mobile no (optional)", name: "mobile", type: "text", optional: true }
    ],
    broker1: [
      { label: "Other Broker Client ID", name: "client_id", type: "text", placeholder: "Other Broker Client ID" },
      { label: "MPIN", name: "mpin", type: "password", placeholder: "MPIN" },
      { label: "API Key", name: "api_key", type: "text", placeholder: "API Key" },
      { label: "Secret Key", name: "secret_key", type: "password", placeholder: "Secret Key" },
      { label: "TOTP Key", name: "totp_secret", type: "text", placeholder: "TOTP Key" },
      { label: "Email Id (optional)", name: "email", type: "text", optional: true, placeholder: "Email Id (optional)" },
      { label: "Mobile no (optional)", name: "mobile", type: "text", optional: true, placeholder: "Mobile no (optional)" }
    ]
  };

  const brokerNameOverrides = {
    broker1: 'Other Broker'
  };

  const brokerColorMap = {
    broker1: "bg-gray",
    flattrade: "bg-indigo",
    acagarwal: "bg-blue",
    motilaloswal: "bg-indigo",
    kotakneo: "bg-red",
    tradejini: "bg-teal",
    zebu: "bg-blue",
    enrichmoney: "bg-gray",
    dhan: "bg-emerald",
    finvasia: "bg-yellow",
    fyers: "bg-indigo",
    groww: "bg-cyan",
    aliceblue: "bg-teal",
    zerodha: "bg-orange"
  };

  const brokerRedirectPaths = {
    zerodha: 'zerodha_redirects',
    fyers: 'fyers_redirects'
  };

  let allAccounts = [];
  let statusFilter = 'all';
  let brokerFilter = '';
  let searchFilter = '';
  let editingAccountId = null;
  let currentBrokerSelected = null;
  let autoLoginResults = cloneAutoLoginResults(state.cachedAutoLoginResults);
  let selectedAccountIds = new Set();

  if (state.cachedFilters) {
    statusFilter = state.cachedFilters.statusFilter || statusFilter;
    brokerFilter = state.cachedFilters.brokerFilter || brokerFilter;
    searchFilter = state.cachedFilters.searchFilter || searchFilter;
    if (Array.isArray(state.cachedFilters.selectedAccountIds)) {
      selectedAccountIds = new Set(state.cachedFilters.selectedAccountIds);
    }
  }

  if (state.cachedAccounts && Array.isArray(state.cachedAccounts.accounts) && state.cachedAccounts.accounts.length) {
    allAccounts = cloneAccountsList(state.cachedAccounts.accounts);
  }

  if (state.cachedAccounts && !state.cachedAccounts.signature) {
    state.cachedAccounts.signature = computeAccountsSignature(state.cachedAccounts.accounts || []);
  }
  if (state.cachedAccounts && !state.cachedAccounts.fetchedAt) {
    state.cachedAccounts.fetchedAt = Date.now();
  }

  persistAutoLoginState();
  pruneAutoLoginResults();

  if (allAccounts.length) {
    populateBrokerCarousel();
    renderAccounts(allAccounts);
    populateBrokerFilter();
    restoreFilterUI();
    updateCounts();
    applyFilters();
  } else {
    restoreFilterUI();
  }
  persistFiltersAndSelection();

  function formatBrokerName(broker) {
    if (!broker) return '';
    if (brokerNameOverrides[broker]) {
      return brokerNameOverrides[broker];
    }  
    return broker
      .split(/[_-]/)
      .map(part => part.charAt(0).toUpperCase() + part.slice(1))
      .join(' ');
  }

  function getBrokerColor(broker) {
    return brokerColorMap[broker] || 'bg-gray';
  }

  function getBrokerInitials(acc) {
    const username = (acc.username || '').trim();
    if (username) {
      const parts = username.split(/\s+/);
      const first = parts[0] ? parts[0].charAt(0) : '';
      const second = parts.length > 1 ? parts[parts.length - 1].charAt(0) : (parts[0] ? parts[0].charAt(1) : '');
      return (first + (second || '')).toUpperCase();
    }
    const client = (acc.client_id || '').toString();
    if (client) {
      return client.substring(0, 2).toUpperCase();
    }
    const broker = (acc.broker || '').toString();
    return broker.substring(0, 2).toUpperCase();
  }

  function escapeHtml(str) {
    if (str === undefined || str === null) return '';
    return String(str)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  function getBaseAppUrl() {
    if (window.appBaseUrl) {
      return String(window.appBaseUrl).replace(/\/$/, '');
    }
    const origin = window.location.origin;
    if (origin) {
      return origin.replace(/\/$/, '');
    }
    const fallback = `${window.location.protocol}//${window.location.host}`;
    return fallback.replace(/\/$/, '');
  }

  function buildRedirectUrl(broker, clientId) {
    const path = brokerRedirectPaths[broker];
    const id = String(clientId || '').trim();
    if (!path || !id) return '';
    const base = getBaseAppUrl();
    return `${base}/${path}/${encodeURIComponent(id)}`;
  }

  function capitalizeWords(str) {
    return String(str || '')
      .replace(/_/g, ' ')
      .replace(/\w/g, match => match.toUpperCase());
  }

  function fetchJson(url, options = {}) {
    options.credentials = options.credentials || 'same-origin';
    return fetch(url, options).then(async response => {
      const text = await response.text();
      let data;
      try {
        data = text ? JSON.parse(text) : {};
      } catch (e) {
        data = { error: text };
      }
      if (!response.ok) {
        const msg = data.error || data.message || response.statusText || 'An unknown error occurred.';
        throw new Error(msg);
      }
      return data;
    });
  }

  function showToast(message, type = 'success') {
    console.log(`[${type.toUpperCase()}] ${message}`);
    alert(message);
  }

  function setDhanStatus(statusEl, message, tone = 'muted') {
    if (!statusEl) {
      return;
    }
    const toneClasses = ['text-muted', 'text-success', 'text-danger', 'text-info', 'text-warning'];
    toneClasses.forEach(cls => statusEl.classList.remove(cls));
    statusEl.textContent = message || '';
    const normalizedTone = tone || 'muted';
    if (normalizedTone === 'muted' || !normalizedTone) {
      statusEl.classList.add('text-muted');
    } else {
      statusEl.classList.add(`text-${normalizedTone}`);
    }
  }

  function setupDhanConsentSection(container) {
    if (!container) {
      dhanConsentController = null;
      return;
    }

    const existing = container.querySelector('.dhan-consent-section');
    if (existing) {
      existing.remove();
    }

    const section = document.createElement('div');
    section.className = 'form-group full-width dhan-consent-section';
    section.innerHTML = `
      <label class="form-label">Dhan Login Flow</label>
      <p class="form-helper text-muted">
        Submitting the Add Account form will open the Dhan consent window automatically. Complete the approval in the new tab
        and return here—we'll restore your details and finish connecting as soon as the token arrives.
      </p>
      <p class="form-helper text-muted" data-dhan-status>We'll update the access token here once consent is complete.</p>
    `;

    container.appendChild(section);

    const accessInput = container.querySelector('input[name="access_token"]');
    if (accessInput && !accessInput.value) {
      accessInput.placeholder = 'Filled automatically after consent';
    }
    const expiryInput = container.querySelector('input[name="token_expiry"]');
    if (expiryInput && !expiryInput.value) {
      expiryInput.placeholder = 'Auto-filled when available';
    }

    const statusEl = section.querySelector('[data-dhan-status]');

    const clientInput = container.querySelector('input[name="client_id"]');
    const apiKeyInput = container.querySelector('input[name="api_key"]');
    const apiSecretInput = container.querySelector('input[name="api_secret"]');
    const nameInput = container.querySelector('input[name="client_name"]');

    restoreDhanFormSnapshot(container);
  
    if (dhanLoginState && accessInput && dhanLoginState.accessToken) {
      accessInput.value = dhanLoginState.accessToken;
    }
    if (dhanLoginState && expiryInput && dhanLoginState.expiry) {
      expiryInput.value = dhanLoginState.expiry;
    }
    if (dhanLoginState && nameInput && dhanLoginState.dhanClientName && !nameInput.value) {
      nameInput.value = dhanLoginState.dhanClientName;
    }
    if (dhanLoginState && clientInput && dhanLoginState.dhanClientId && !clientInput.value) {
      clientInput.value = dhanLoginState.dhanClientId;
    }

    if (dhanLoginState && statusEl) {
      setDhanStatus(statusEl, 'Access token restored from your previous login.', 'info');
    }

    const getTrimmedValue = input => (input && typeof input.value === 'string' ? input.value.trim() : '');

    const runStartConsent = async (options = {}) => {
      const { setPendingSubmit = false } = options;
      const clientId = getTrimmedValue(clientInput);
      const apiKey = getTrimmedValue(apiKeyInput);
      const apiSecret = getTrimmedValue(apiSecretInput);

      if (!clientId || !apiKey || !apiSecret) {
        showToast('Enter Client ID, API Key, and API Secret before we can launch the Dhan consent.', 'warning');
        setDhanStatus(statusEl, 'Provide Client ID, API Key, and API Secret so we can launch the consent flow.', 'warning');
        return false;
      }

      persistDhanFormSnapshot(container);
      if (!setPendingSubmit) {
        clearPendingDhanSubmission();
      }

      clearDhanLoginState();
      if (accessInput) accessInput.value = '';
      if (expiryInput) expiryInput.value = '';

      setDhanStatus(statusEl, 'Opening Dhan consent in a new tab...', 'info');

      try {
        const response = await fetchJson('/api/dhan/login/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            client_id: clientId,
            api_key: apiKey,
            api_secret: apiSecret
          })
        });

        if (response && response.login_url) {
          if (setPendingSubmit) {
            markPendingDhanSubmission();
          }
          window.open(response.login_url, '_blank', 'noopener');
          const successMessage = 'Consent page opened. Complete the approval on Dhan and return here to finish connecting automatically.';
          setDhanStatus(statusEl, successMessage, 'success');
          showToast(successMessage, 'info');
          return true;
        }

        setDhanStatus(statusEl, 'Failed to receive a consent URL from Dhan.', 'danger');
        showToast('Failed to start Dhan login: missing consent URL.', 'error');
        return false;
      } catch (error) {
        setDhanStatus(statusEl, error.message || 'Failed to start Dhan login.', 'danger');
        showToast(`Failed to start Dhan login: ${error.message}`, 'error');
        return false;
      }
    };

    const runCompleteConsent = async (providedTokenId, options = {}) => {
      const { triggeredByCallback = false } = options;
      const tokenId = (providedTokenId || '').trim();

      if (!tokenId) {
        if (!triggeredByCallback) {
          showToast('Waiting for the token from Dhan. Complete the consent in the opened tab.', 'warning');
          setDhanStatus(statusEl, 'Waiting for the token from Dhan to finish connecting your account.', 'warning');
        }
        return null;
      }

      let clientId = getTrimmedValue(clientInput);
      let apiKey = getTrimmedValue(apiKeyInput);
      let apiSecret = getTrimmedValue(apiSecretInput);

      if (!clientId || !apiKey || !apiSecret) {
        restoreDhanFormSnapshot(container);
        clientId = clientId || getTrimmedValue(clientInput);
        apiKey = apiKey || getTrimmedValue(apiKeyInput);
        apiSecret = apiSecret || getTrimmedValue(apiSecretInput);
      }

      if (!clientId || !apiKey || !apiSecret) {
        showToast('Client ID, API Key, and API Secret are required to complete the Dhan login.', 'warning');
        setDhanStatus(statusEl, 'Provide Client ID, API Key, and API Secret to complete login.', 'warning');
        return null;
      }

      persistDhanFormSnapshot(container);

      setDhanStatus(statusEl, 'Finishing consent flow and fetching token...', 'info');
      if (triggeredByCallback) {
        showToast('Completing Dhan login with the returned token...', 'info');
      }

      let responsePayload = null;
      let completedSuccessfully = false;

      try {
        const response = await fetchJson('/api/dhan/login/complete', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            token_id: tokenId,
            api_key: apiKey,
            api_secret: apiSecret,
            client_id: clientId
          })
        });

        responsePayload = response;

        const accessToken = response.access_token || '';
        const expiry = response.expiry_time || '';

        if (accessInput) {
          accessInput.value = accessToken;
          try {
            accessInput.dispatchEvent(new Event('input', { bubbles: true }));
          } catch (error) {
            console.warn('Failed to dispatch input event for access token', error);
          }
        }
        if (expiryInput) {
          expiryInput.value = expiry;
          try {
            expiryInput.dispatchEvent(new Event('input', { bubbles: true }));
          } catch (error) {
            console.warn('Failed to dispatch input event for token expiry', error);
          }
        }
        if (response.dhan_client_name && nameInput && !nameInput.value) {
          nameInput.value = response.dhan_client_name;
        }
        if (response.dhan_client_id && clientInput && !clientInput.value) {
          clientInput.value = response.dhan_client_id;
        }

        const rawPayload = response.raw && typeof response.raw === 'object' ? response.raw : null;
        const tokenTime = rawPayload
          ? rawPayload.tokenGenerationTime || rawPayload.token_generation_time || rawPayload.generatedAt
          : null;

        dhanLoginState = {
          tokenId,
          accessToken,
          expiry,
          payload: rawPayload,
          tokenTime: tokenTime || null,
          completedAt: new Date().toISOString(),
          dhanClientId: response.dhan_client_id || clientId,
          dhanClientName: response.dhan_client_name || (nameInput ? nameInput.value : '')
        };
        persistDhanLoginState();
        clearPersistedDhanForm();

        setDhanStatus(statusEl, 'Access token fetched successfully from Dhan.', 'success');
        showToast('Dhan login completed and access token filled automatically.');
        completedSuccessfully = true;
      } catch (error) {
        setDhanStatus(statusEl, error.message || 'Failed to complete Dhan login.', 'danger');
        showToast(`Failed to complete Dhan login: ${error.message}`, 'error');
      } finally {
        if (completedSuccessfully) {
          const shouldAutoSubmit = consumePendingDhanSubmission();
          if (shouldAutoSubmit && !editingAccountId) {
            setDhanStatus(statusEl, 'Access token fetched. Completing account connection...', 'info');
            showToast('Finishing Dhan account connection…', 'info');
            window.requestAnimationFrame(() => {
              const formEl = document.getElementById('broker-credentials-form');
              if (formEl) {
                try {
                  formEl.requestSubmit();
                } catch (submitError) {
                  console.warn('Automatic Dhan form submission failed:', submitError);
                }
              }
            });
          }
        }
      }

      return responsePayload;
    };

    dhanConsentController = {
      container,
      start: runStartConsent,
      complete: runCompleteConsent,
    };

    const tokenFromCallback = pendingDhanTokenId;
    if (tokenFromCallback) {
      pendingDhanTokenId = null;
      if (statusEl) {
        setDhanStatus(statusEl, 'Completing Dhan login with the returned token...', 'info');
      }
      runCompleteConsent(tokenFromCallback, { triggeredByCallback: true }).catch(error => {
        console.error('Automatic Dhan login completion failed:', error);
      });
    }
  }

  function populateBrokerCarousel(searchTerm = '') {
    const scrollContainer = document.querySelector('.broker-scroll');
    if (!scrollContainer) return;

    const search = searchTerm.trim().toLowerCase();
    const brokers = Object.keys(brokerFields);
    const filtered = search
      ? brokers.filter(b => formatBrokerName(b).toLowerCase().includes(search))
      : brokers;

    const ordered = !search && filtered.length
      ? [filtered[filtered.length - 1], ...filtered.slice(0, -1)]
      : filtered;

    if (!ordered.length) {
      scrollContainer.innerHTML = '<p class="broker-empty">No brokers found.</p>';
      return;
    }

    scrollContainer.innerHTML = ordered.map(broker => {
      const brokerName = formatBrokerName(broker);
      const iconUrl = brokerIcons[broker];
      const isActive = currentBrokerSelected === broker;
      const initials = brokerName ? brokerName.substring(0, 2).toUpperCase() : broker.substring(0, 2).toUpperCase();
      const avatarContent = iconUrl
        ? `<img src="${iconUrl}" alt="${escapeHtml(brokerName)}">`
        : `<span>${escapeHtml(initials)}</span>`;
      return `
        <button class="broker-card ${isActive ? 'active' : ''}" type="button" data-broker="${broker}" title="${escapeHtml(brokerName)}">
          <div class="broker-avatar ${getBrokerColor(broker)}">
            ${avatarContent}
          </div>
          <span class="broker-name">${escapeHtml(brokerName)}</span>
        </button>
      `;
    }).join('');

    scrollContainer.querySelectorAll('.broker-card').forEach(item => {
      item.addEventListener('click', function () {
        scrollContainer.querySelectorAll('.broker-card').forEach(i => i.classList.remove('active'));
        this.classList.add('active');
        showBrokerForm(this.dataset.broker);
      });
    });
  }

  function getSelectedBroker() {
    const selected = document.querySelector('.broker-card.active');
    return selected ? selected.dataset.broker : null;
  }

  function showBrokerForm(broker) {
    currentBrokerSelected = broker;
    const fields = brokerFields[broker];
    const container = document.getElementById('broker-fields');
    const submitBtn = document.getElementById('submit-account-btn');
    const resultDiv = document.getElementById('cred-check-result');
    const formActions = document.querySelector('.form-actions');

    if (!container) return;

    container.innerHTML = '';
    if (resultDiv) resultDiv.textContent = '';
    if (submitBtn) submitBtn.style.display = 'none';
    if (formActions) formActions.style.display = 'none';

    if (!fields) {
      container.innerHTML = '<p class="form-placeholder">No configuration fields defined for this broker.</p>';
      return;
    }

    let formHtml = '';
    if (broker !== 'broker1') {
      formHtml += `
        <div class="form-group">
          <label class="form-label" for="username">Username (for your reference)</label>
          <input class="form-input" name="username" type="text" id="username" required>
        </div>`;
    }

    fields.forEach(f => {
      const inputName = typeof f.name === 'string' ? f.name : '';
      const inputType = typeof f.type === 'string' ? f.type : 'text';
      const placeholder = typeof f.placeholder === 'string' ? f.placeholder : f.label;
      const inputId = escapeHtml(inputName);

      const classList = ['form-input'];
      if (f.className) classList.push(f.className);
      if (f.readonly) classList.push('bg-light', 'input-readonly');

      const attributeParts = [
        `class="${escapeHtml(classList.join(' '))}"`,
        `name="${escapeHtml(inputName)}"`,
        `type="${escapeHtml(inputType)}"`,
        `id="${inputId}"`,
        `placeholder="${escapeHtml(placeholder || '')}"`
      ];

      if (!f.optional) {
        attributeParts.push('required');
      }
      if (f.readonly) {
        attributeParts.push('readonly', 'aria-readonly="true"', 'data-force-readonly="true"');
      }
      if (f.autofillOnly) {
        attributeParts.push('data-autofill-only="true"');
      }
      if (f.autocomplete) {
        attributeParts.push(`autocomplete="${escapeHtml(f.autocomplete)}"`);
      }
      if (typeof f.maxlength === 'number') {
        attributeParts.push(`maxlength="${escapeHtml(String(f.maxlength))}"`);
      }

      const attributeString = attributeParts.join(' ');

      if (inputType === 'password') {
        formHtml += `
        <div class="form-group">
          <label class="form-label" for="${inputId}">${escapeHtml(f.label)}</label>
          <div class="password-field">
            <input ${attributeString}>
            <button class="toggle-password" type="button" data-target="${inputId}" aria-label="Toggle password visibility">
              <i class="bi bi-eye"></i>
            </button>
          </div>
          ${f.tip ? `<p class="form-helper text-muted">${escapeHtml(f.tip)}</p>` : ''}
        </div>`;
      } else {
        formHtml += `
        <div class="form-group">
          <label class="form-label" for="${inputId}">${escapeHtml(f.label)}</label>
          <input ${attributeString}>
          ${f.tip ? `<p class="form-helper text-muted">${escapeHtml(f.tip)}</p>` : ''}
        </div>`;
      }
    });

    container.innerHTML = formHtml;
    container.querySelectorAll('.toggle-password').forEach(btn => {
      btn.addEventListener('click', function () {
        const target = container.querySelector(`#${CSS.escape(this.dataset.target)}`);
        if (target) {
          const show = target.type === 'password';
          target.type = show ? 'text' : 'password';
          this.innerHTML = show ? '<i class="bi bi-eye-slash"></i>' : '<i class="bi bi-eye"></i>';
        }
      });
    });

    if (submitBtn) submitBtn.style.display = 'inline-flex';
    if (formActions) formActions.style.display = 'flex';

    if (broker === 'dhan') {
      setupDhanConsentSection(container);
    } else {
      clearDhanLoginState();
      clearPendingDhanSubmission();
      dhanConsentController = null;
    }

    if (brokerRedirectPaths[broker]) {
      const redirectInputId = `${broker}-redirect-url`;
      const brokerDisplayName = formatBrokerName(broker);
      const redirectGroup = document.createElement('div');
      redirectGroup.className = 'form-group full-width redirect-url-group';
      redirectGroup.innerHTML = `
        <label class="form-label" for="${escapeHtml(redirectInputId)}">${escapeHtml(brokerDisplayName)} Redirect URL</label>
        <div class="copy-field">
          <input class="form-input" type="text" id="${escapeHtml(redirectInputId)}" readonly placeholder="Enter Client ID to generate redirect URL">
          <button class="btn btn-outline" type="button" data-action="copy-redirect">Copy URL</button>
        </div>
        <p class="form-helper">Use this redirect URL while configuring your ${escapeHtml(brokerDisplayName)} app.</p>
      `;

      container.appendChild(redirectGroup);

      const redirectInput = redirectGroup.querySelector(`#${CSS.escape(redirectInputId)}`);
      const copyBtn = redirectGroup.querySelector('[data-action="copy-redirect"]');
      const clientInput = container.querySelector('input[name="client_id"]');

      const updateRedirectUrl = () => {
        const value = clientInput ? clientInput.value : '';
        const url = buildRedirectUrl(broker, value);
        if (redirectInput) redirectInput.value = url;
        if (copyBtn) copyBtn.disabled = !url;
      };

      if (clientInput) {
        clientInput.addEventListener('input', updateRedirectUrl);
        updateRedirectUrl();
      } else if (copyBtn) {
        copyBtn.disabled = true;
      }

      if (copyBtn) {
        copyBtn.addEventListener('click', () => {
          if (copyBtn.disabled) return;
          const value = redirectInput ? redirectInput.value : '';
          if (!value) {
            showToast('Enter client ID to generate redirect URL first.', 'warning');
            return;
          }
          copyToClipboard(value, 'Redirect URL copied to clipboard.');
        });
      }
    }
  }

  function activateBroker(broker) {
    if (!broker) {
      return;
    }
    const cards = document.querySelectorAll('.broker-card');
    let found = false;
    cards.forEach(card => {
      const isTarget = card.dataset.broker === broker;
      card.classList.toggle('active', isTarget);
      if (isTarget) {
        found = true;
      }
    });
    showBrokerForm(broker);
    if (!found) {
      window.requestAnimationFrame(() => {
        document.querySelectorAll('.broker-card').forEach(card => {
          card.classList.toggle('active', card.dataset.broker === broker);
        });
      });
    }
  }

  function openAddAccountForm() {
    const addAccountSection = document.getElementById('add-account-section');
    const addBtnText = document.getElementById('add-btn-text');
    const addAccountBtn = document.getElementById('add-account-btn');
    if (addAccountSection) addAccountSection.style.display = 'block';
    if (addBtnText) addBtnText.textContent = 'Cancel';
    if (addAccountBtn) addAccountBtn.setAttribute('aria-expanded', 'true');
  }

  function hideBrokerForm() {
    const addAccountSection = document.getElementById('add-account-section');
    const addBtnText = document.getElementById('add-btn-text');
    const addAccountBtn = document.getElementById('add-account-btn');
    const form = document.getElementById('broker-credentials-form');
    const submitBtn = document.getElementById('submit-account-btn');

    if (form) {
      form.reset();
      form.querySelectorAll('input').forEach(input => {
        const forceReadonly = input.dataset.forceReadonly === 'true' || input.dataset.autofillOnly === 'true';
        if (forceReadonly) {
          input.readOnly = true;
          input.classList.add('bg-light', 'input-readonly');
        } else {
          input.readOnly = false;
          input.classList.remove('bg-light', 'input-readonly');
        }
      });
    }

    const brokerSearchInput = document.getElementById('broker-search');
    if (brokerSearchInput) brokerSearchInput.value = '';

    if (submitBtn) submitBtn.textContent = 'Add Account';
    editingAccountId = null;
    currentBrokerSelected = null;

    clearDhanLoginState();
    clearPersistedDhanForm();
    clearPendingDhanSubmission();
    dhanConsentController = null;
    
    document.querySelectorAll('.broker-card').forEach(i => i.classList.remove('active'));
    populateBrokerCarousel();

    if (addAccountSection) addAccountSection.style.display = 'none';
    if (addBtnText) addBtnText.textContent = 'Add New Account';
    if (addAccountBtn) addAccountBtn.setAttribute('aria-expanded', 'false');

    const resultDiv = document.getElementById('cred-check-result');
    if (resultDiv) resultDiv.textContent = '';
  }

  function sanitizeClientId(id) {
    return String(id || '').replace(/[^a-zA-Z0-9_-]/g, '');
  }

  function getAccountRowId(acc, index = 0) {
    if (acc && acc._rowId) {
      return acc._rowId;
    }

    const candidates = [
      acc && acc.client_id,
      acc && acc.username,
      acc && acc.account_id,
      acc && acc.id,
      `${acc && acc.broker ? acc.broker : 'broker'}-${index}`
    ];

    for (const candidate of candidates) {
      const sanitized = sanitizeClientId(candidate);
      if (sanitized) {
        if (acc) acc._rowId = sanitized;
        return sanitized;
      }
    }

    const fallback = `acc-${index}-${Math.random().toString(36).slice(2, 8)}`;
    if (acc) acc._rowId = fallback;
    return fallback;
  }

  function getAccountByRowId(rowId) {
    if (!rowId) return null;
    for (let i = 0; i < allAccounts.length; i += 1) {
      const acc = allAccounts[i];
      if (getAccountRowId(acc, i) === rowId) {
        return acc;
      }
    }
    return null;
  }

  function getSelectedAccounts() {
    return Array.from(selectedAccountIds)
      .map(id => getAccountByRowId(id))
      .filter(Boolean);
  }

  function clearSelection() {
    selectedAccountIds = new Set();
    updateSelectionUI();
  }

  function formatBalance(balance) {
    if (typeof balance === 'number' && !Number.isNaN(balance)) {
      return `₹${balance.toLocaleString('en-IN')}`;
    }
    if (typeof balance === 'string' && balance.trim()) {
      return balance;
    }
    return '—';
  }

  function formatDateTime(value) {
    if (!value) return '--';
    const date = value instanceof Date ? value : new Date(value);
    if (Number.isNaN(date.getTime())) return '--';
    return date.toLocaleString('en-IN', { hour12: false });
  }

  function getDeveloperUrl(acc) {
    const creds = acc.credentials || {};
    return creds.developer_url || creds.redirect_uri || creds.api_url || creds.url || '';
  }

  function getStaticIp(acc) {
    const creds = acc.credentials || {};
    return creds.static_ip || creds.ip || acc.device_number || '';
  }

  function renderCopyCell(type, value) {
    if (!value) {
      return '<span class="text-xs text-muted">--</span>';
    }
    const label = type === 'url' ? 'Copy URL' : 'Copy IP';
    return `
      <button class="btn btn-sm btn-success" type="button" data-action="copy-${type}">
        <svg class="icon icon-sm" viewBox="0 0 24 24" aria-hidden="true">
          <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
          <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
        </svg>
        ${label}
      </button>
    `;
  }

  function renderActionCell(acc, sanitizedId) {
    const dropdownId = `dropdown-${sanitizedId}`;
    const hasUrl = !!getDeveloperUrl(acc);
    const hasIp = !!getStaticIp(acc);
    return `
      <div class="flex items-center gap-2">
        <button class="btn btn-sm btn-success mobile-hide" type="button" data-action="reconnect">
          <svg class="icon icon-sm" viewBox="0 0 24 24" aria-hidden="true">
            <polyline points="23 4 23 10 17 10"></polyline>
            <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
          </svg>
          Reconnect
        </button>
        <div class="dropdown" id="${dropdownId}">
          <button class="btn btn-icon btn-ghost" type="button" data-dropdown-toggle="${dropdownId}" aria-haspopup="true" aria-expanded="false">
            <svg class="icon" viewBox="0 0 24 24" aria-hidden="true">
              <circle cx="12" cy="12" r="1"></circle>
              <circle cx="12" cy="5" r="1"></circle>
              <circle cx="12" cy="19" r="1"></circle>
            </svg>
          </button>
          <div class="dropdown-menu" role="menu">
            <button class="dropdown-item" type="button" data-action="reconnect">
              <svg class="icon icon-sm" viewBox="0 0 24 24" aria-hidden="true">
                <polyline points="23 4 23 10 17 10"></polyline>
                <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
              </svg>
              Reconnect
            </button>
            <button class="dropdown-item${hasUrl ? '' : ' disabled'}" type="button" data-action="copy-url" data-requires="url">
              <svg class="icon icon-sm" viewBox="0 0 24 24" aria-hidden="true">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
              </svg>
              Copy URL
            </button>
            <button class="dropdown-item${hasIp ? '' : ' disabled'}" type="button" data-action="copy-ip" data-requires="ip">
              <svg class="icon icon-sm" viewBox="0 0 24 24" aria-hidden="true">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
              </svg>
              Copy IP
            </button>
            <button class="dropdown-item" type="button" data-action="edit">
              <svg class="icon icon-sm" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
              </svg>
              Edit
            </button>
            <button class="dropdown-item danger" type="button" data-action="delete">
              <svg class="icon icon-sm" viewBox="0 0 24 24" aria-hidden="true">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
              </svg>
              Delete
            </button>
          </div>
        </div>
      </div>
    `;
  }

  function renderStatusBadge(acc) {
    const auto = autoLoginResults[acc.client_id];
    const lastErr = acc.last_error || (Array.isArray(acc.errors) ? acc.errors[0] : acc.errors);
    if (auto) {
      if (auto.status === 'error') {
        const msg = auto.error ? escapeHtml(auto.error) : 'Error';
        return `<span class="badge badge-danger" title="${msg}">Error</span>`;
      }
      if (auto.status === 'checking') {
        return '<span class="badge badge-secondary">Connecting...</span>';
      }
    }
    const status = (acc.status || '').toLowerCase();
    if (status === 'connected') {
      return '<span class="badge badge-success">Success</span>';
    }
    if (status === 'pending') {
      return '<span class="badge badge-secondary">Pending</span>';
    }
    if (status) {
      const label = lastErr ? String(lastErr) : status;
      const truncated = label.length > 32 ? `${label.slice(0, 29)}…` : label;
      return `<span class="badge badge-danger" title="${escapeHtml(label)}">${escapeHtml(truncated)}</span>`;
    }
    return '<span class="badge badge-danger">Error</span>';
  }

  function renderAccounts(accountsToRender) {
    const tbody = document.getElementById('accounts-table-body');
    if (!tbody) return;
    tbody.innerHTML = '';

    accountsToRender.forEach((acc, index) => {
      const sanitizedId = getAccountRowId(acc, index);
      const row = document.createElement('tr');
      row.dataset.clientId = sanitizedId;
      row.dataset.developerUrl = getDeveloperUrl(acc) || '';
      row.dataset.staticIp = getStaticIp(acc) || '';

      const primaryLabel = acc.username || acc.client_id || '—';
      const secondaryLabel = acc.client_id || '';

      row.innerHTML = `
        <td>
          <input type="checkbox" class="checkbox account-select" data-client-id="${sanitizedId}" aria-label="Select account ${escapeHtml(primaryLabel)}">
        </td>
        <td>
          <div class="flex items-center gap-2">
            <div class="avatar ${getBrokerColor(acc.broker)}">${escapeHtml(getBrokerInitials(acc))}</div>
            <div>
              <p class="font-medium text-sm truncate" title="${escapeHtml(primaryLabel)}">${escapeHtml(primaryLabel)}</p>
              <p class="text-xs text-muted truncate" title="${escapeHtml(secondaryLabel)}">${escapeHtml(secondaryLabel)}</p>
            </div>
          </div>
        </td>
        <td class="mobile-hide lg-show">
          <div class="balance-cell">
            <span class="text-sm balance-text" data-field="balance">${escapeHtml(formatBalance(acc.opening_balance))}</span>
            <button class="balance-refresh-btn" type="button" data-action="refresh-balance" title="Refresh balance" aria-label="Refresh balance"${acc && acc.client_id ? '' : ' disabled'}>
              <svg class="icon" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M21 2v6h-6"></path>
                <path d="M3 12a9 9 0 0 1 15-6.7L21 8"></path>
                <path d="M3 22v-6h6"></path>
                <path d="M21 12a9 9 0 0 1-15 6.7L3 16"></path>
              </svg>
            </button>
          </div>
        </td>
        <td><div data-field="status">${renderStatusBadge(acc)}</div></td>
        <td class="mobile-hide md-show"><span class="text-xs" data-field="last-login">${escapeHtml(formatDateTime(acc.last_login))}</span></td>
        <td class="mobile-hide xl-show" data-field="developer-cell">${renderCopyCell('url', row.dataset.developerUrl)}</td>
        <td class="mobile-hide xl-show" data-field="static-cell">${renderCopyCell('ip', row.dataset.staticIp)}</td>
        <td data-field="action-cell">${renderActionCell(acc, sanitizedId)}</td>
      `;

      const checkbox = row.querySelector('.account-select');
      if (checkbox) {
        checkbox.checked = selectedAccountIds.has(sanitizedId);
      }

      tbody.appendChild(row);
    });

    updateSelectionUI();
  }

  function updateBulkActionsMenu() {
    const dropdown = document.getElementById('more-dropdown');
    if (!dropdown) return;
    const menu = dropdown.querySelector('.dropdown-menu');
    if (!menu) return;

    const selectedCount = selectedAccountIds.size;
    const selectedAccounts = selectedCount === 1 ? getSelectedAccounts() : [];
    const accountLabel = selectedAccounts.length
      ? escapeHtml(
          selectedAccounts[0].client_id ||
          selectedAccounts[0].username ||
          formatBrokerName(selectedAccounts[0].broker) ||
          'Account'
        )
      : '';

    if (selectedCount === 0) {
      menu.innerHTML = `
        <button class="dropdown-item" type="button" data-bulk-action="export-visible">
          <svg class="icon icon-sm" viewBox="0 0 24 24" aria-hidden="true">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="7 10 12 15 17 10"></polyline>
            <line x1="12" y1="15" x2="12" y2="3"></line>
          </svg>
          Export Visible Accounts
        </button>
        <div class="dropdown-divider" role="separator"></div>
        <div class="dropdown-empty text-xs text-muted">Select accounts to enable quick actions.</div>
      `;
      return;
    }

    if (selectedCount === 1) {
      menu.innerHTML = `
        <div class="dropdown-header text-xs text-muted">${accountLabel}</div>
        <button class="dropdown-item" type="button" data-bulk-action="single-reconnect">
          <svg class="icon icon-sm" viewBox="0 0 24 24" aria-hidden="true">
            <polyline points="23 4 23 10 17 10"></polyline>
            <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
          </svg>
          Reconnect
        </button>
        <button class="dropdown-item" type="button" data-bulk-action="single-update">
          <svg class="icon icon-sm" viewBox="0 0 24 24" aria-hidden="true">
            <polyline points="4 12 12 4 20 12"></polyline>
            <line x1="12" y1="4" x2="12" y2="20"></line>
          </svg>
          Update
        </button>
        <button class="dropdown-item" type="button" data-bulk-action="single-edit">
          <svg class="icon icon-sm" viewBox="0 0 24 24" aria-hidden="true">
            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
            <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
          </svg>
          Edit
        </button>
        <button class="dropdown-item danger" type="button" data-bulk-action="single-delete">
          <svg class="icon icon-sm" viewBox="0 0 24 24" aria-hidden="true">
            <polyline points="3 6 5 6 21 6"></polyline>
            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
          </svg>
          Delete
        </button>
        <button class="dropdown-item" type="button" data-bulk-action="single-export">
          <svg class="icon icon-sm" viewBox="0 0 24 24" aria-hidden="true">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="7 10 12 15 17 10"></polyline>
            <line x1="12" y1="15" x2="12" y2="3"></line>
          </svg>
          Export
        </button>
      `;
      return;
    }

    menu.innerHTML = `
      <div class="dropdown-header text-xs text-muted">${selectedCount} accounts selected</div>
      <button class="dropdown-item" type="button" data-bulk-action="bulk-reconnect">
        <svg class="icon icon-sm" viewBox="0 0 24 24" aria-hidden="true">
          <polyline points="23 4 23 10 17 10"></polyline>
          <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
        </svg>
        Reconnect Selected
      </button>
      <button class="dropdown-item danger" type="button" data-bulk-action="bulk-delete">
        <svg class="icon icon-sm" viewBox="0 0 24 24" aria-hidden="true">
          <polyline points="3 6 5 6 21 6"></polyline>
          <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
        </svg>
        Delete Selected
      </button>
      <button class="dropdown-item" type="button" data-bulk-action="bulk-export">
        <svg class="icon icon-sm" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
          <polyline points="7 10 12 15 17 10"></polyline>
          <line x1="12" y1="15" x2="12" y2="3"></line>
        </svg>
        Export Selected
      </button>
    `;
  }

  function updateSelectionUI() {
    const knownIds = new Set(allAccounts.map((acc, index) => getAccountRowId(acc, index)));
    selectedAccountIds = new Set(Array.from(selectedAccountIds).filter(id => knownIds.has(id)));

    const tbody = document.getElementById('accounts-table-body');
    const selectAllCheckbox = document.getElementById('select-all-accounts');
    const visibleIds = new Set();

    if (tbody) {
      Array.from(tbody.querySelectorAll('tr')).forEach(row => {
        const rowId = row.dataset.clientId;
        if (!rowId) return;
        if (row.style.display !== 'none') {
          visibleIds.add(rowId);
        }
        const checkbox = row.querySelector('.account-select');
        if (checkbox) {
          checkbox.checked = selectedAccountIds.has(rowId);
          checkbox.indeterminate = false;
        }
      });
    }

    if (selectAllCheckbox) {
      if (!visibleIds.size) {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = false;
        selectAllCheckbox.disabled = true;
      } else {
        selectAllCheckbox.disabled = false;
        const selectedVisibleCount = Array.from(visibleIds).filter(id => selectedAccountIds.has(id)).length;
        if (selectedVisibleCount === visibleIds.size) {
          selectAllCheckbox.checked = true;
          selectAllCheckbox.indeterminate = false;
        } else if (selectedVisibleCount === 0) {
          selectAllCheckbox.checked = false;
          selectAllCheckbox.indeterminate = false;
        } else {
          selectAllCheckbox.checked = false;
          selectAllCheckbox.indeterminate = true;
        }
      }
    }

    updateBulkActionsMenu();
    persistFiltersAndSelection();
  }

  function populateBrokerFilter() {
    const select = document.getElementById('broker-filter');
    if (!select) return;
    const desiredValue = brokerFilter || select.value;
    const brokers = [...new Set(allAccounts.map(a => a.broker).filter(Boolean))].sort();
    const options = ['<option value="">All Brokers</option>'];
    brokers.forEach(b => {
      options.push(`<option value="${b}">${escapeHtml(formatBrokerName(b))}</option>`);
    });
    select.innerHTML = options.join('');
    if (desiredValue && brokers.includes(desiredValue)) {
      select.value = desiredValue;
      brokerFilter = desiredValue;
    } else {
      select.value = '';
      if (brokerFilter) {
        brokerFilter = '';
      }
    }
  }

  function matchesFilters(acc) {
    let matches = true;
    if (statusFilter === 'success') {
      matches = (acc.status || '').toLowerCase() === 'connected';
    } else if (statusFilter === 'failed') {
      matches = (acc.status || '').toLowerCase() !== 'connected';
    }

    if (matches && brokerFilter) {
      matches = acc.broker === brokerFilter;
    }

    if (matches && searchFilter) {
      const term = searchFilter.toLowerCase();
      matches = String(acc.client_id || '').toLowerCase().includes(term) || (acc.username || '').toLowerCase().includes(term);
    }

    return matches;
  }

  function getFilteredAccounts() {
    return allAccounts.filter(acc => matchesFilters(acc));
  }

  function updateFooterCounts(filteredAccounts) {
    const filteredTotal = filteredAccounts.length;
    const overallTotal = allAccounts.length;

    const summary = document.getElementById('accounts-summary');
    if (summary) {
      if (!filteredTotal) {
        summary.textContent = 'No accounts to display';
      } else if (filteredTotal === overallTotal) {
        summary.textContent = `Showing ${filteredTotal} account${filteredTotal === 1 ? '' : 's'}`;
      } else {
        summary.textContent = `Showing ${filteredTotal} of ${overallTotal} accounts`;
      }
    }

    const range = document.getElementById('accounts-range');
    if (range) {
      range.textContent = filteredTotal ? `1-${filteredTotal} of ${filteredTotal}` : '0-0 of 0';
    }
  }

  function updateEmptyState() {
    const tbody = document.getElementById('accounts-table-body');
    const emptyState = document.getElementById('accounts-empty-state');
    if (!tbody || !emptyState) return;
    const hasVisible = Array.from(tbody.querySelectorAll('tr')).some(row => row.style.display !== 'none');
    emptyState.style.display = hasVisible ? 'none' : 'flex';
  }

  function applyFilters() {
    const tbody = document.getElementById('accounts-table-body');
    if (!tbody) return;
    const filteredAccounts = getFilteredAccounts();
    const visibleIds = new Set(
      filteredAccounts.map(acc => sanitizeClientId(acc.client_id || acc.username || ''))
    );

    Array.from(tbody.querySelectorAll('tr')).forEach(row => {
      row.style.display = visibleIds.has(row.dataset.clientId) ? '' : 'none';
    });
    updateEmptyState();
    updateFooterCounts(filteredAccounts);
    updateSelectionUI();
    persistFiltersAndSelection();
  }

  function updateCounts() {
    const total = allAccounts.length;
    const connected = allAccounts.filter(a => (a.status || '').toLowerCase() === 'connected').length;
    const failed = total - connected;

    const setText = (id, value) => {
      const el = document.getElementById(id);
      if (el) el.textContent = value;
    };

    setText('tab-count-all', total);
    setText('tab-count-success', connected);
    setText('tab-count-failed', failed);
    setText('master-accounts-count', allAccounts.filter(acc => acc.role === 'master').length);
    setText('child-accounts-count', allAccounts.filter(acc => acc.role === 'child').length);
    setText('total-capacity', total.toString());
    setText('current-plan', 'Professional');
    setText('plan-validity', '--');

    updateFooterCounts(getFilteredAccounts());
  }

  function updateAccountCard() {
    renderAccounts(allAccounts);
    applyFilters();
  }

  async function attemptAutoLoginForAccount(acc) {
    if (!isActive) return;
    autoLoginResults[acc.client_id] = { status: 'checking' };
    persistAutoLoginState();  
    const controller = new AbortController();
    const unregister = registerAbortController(controller);
    try {
      const resp = await fetchJson('/api/reconnect-account', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ client_id: acc.client_id }),
        signal: controller.signal
      });
      if (!isActive) return;
      if (resp.message) {
        autoLoginResults[acc.client_id] = { status: 'success' };
        persistAutoLoginState();
        const updatedAcc = allAccounts.find(a => a.client_id === acc.client_id);
        if (updatedAcc) updatedAcc.status = 'connected';
      } else {
        autoLoginResults[acc.client_id] = { status: 'error', error: resp.error || 'Error' };
        persistAutoLoginState();
        const updatedAcc = allAccounts.find(a => a.client_id === acc.client_id);
        if (updatedAcc) {
          updatedAcc.status = 'failed';
          updatedAcc.last_error = resp.error;
        }
      }
    } catch (err) {
      if (controller.signal.aborted || !isActive) {
        return;
      }
      autoLoginResults[acc.client_id] = { status: 'error', error: err.message };
      persistAutoLoginState();
      const updatedAcc = allAccounts.find(a => a.client_id === acc.client_id);
      if (updatedAcc) {
        updatedAcc.status = 'failed';
        updatedAcc.last_error = err.message;
      }
    } finally {
      unregister();
    }
  }

  async function refreshBalanceForAccount(acc, options = {}) {
    if (!isActive) return false;
    const { cacheOnly = true } = options || {};
    const controller = new AbortController();
    const unregister = registerAbortController(controller);
    try {
      const requestBody = { client_id: acc.client_id };
      if (cacheOnly) {
        requestBody.cache_only = true;
      }
      const resp = await fetchJson('/api/account-balance', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
        signal: controller.signal
      });
      if (!isActive) return false;
      if (resp && resp.error) {
        throw new Error(resp.error);
      }
      const hasBalance = typeof resp.balance === 'number';
      if (hasBalance) {
        const updatedAcc = allAccounts.find(a => a.client_id === acc.client_id);
        if (updatedAcc) updatedAcc.opening_balance = resp.balance;
      }
      return hasBalance;
    } catch (err) {
      if (controller.signal.aborted || !isActive) {
        return false;
      }
      if (!controller.signal.aborted && isActive) {
        console.error(`Balance refresh failed for ${acc.client_id}:`, err);
      }
      throw err;
    } finally {
      unregister();
    }
  }

  async function copyToClipboard(text, successMessage) {
    if (!text) {
      showToast('No data available to copy.', 'warning');
      return;
    }
    try {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        await navigator.clipboard.writeText(text);
      } else {
        const temp = document.createElement('textarea');
        temp.value = text;
        temp.style.position = 'fixed';
        temp.style.opacity = '0';
        document.body.appendChild(temp);
        temp.select();
        document.execCommand('copy');
        document.body.removeChild(temp);
      }
      showToast(successMessage || 'Copied to clipboard.');
    } catch (err) {
      console.error('Clipboard copy failed:', err);
      showToast('Failed to copy to clipboard.', 'error');
    }
  }

  function toCsvValue(value) {
    const text = value === undefined || value === null ? '' : String(value);
    return `"${text.replace(/"/g, '""')}"`;
  }

  function exportAccountsData(accounts, filenameSuffix = 'accounts') {
    if (!Array.isArray(accounts) || !accounts.length) {
      showToast('No accounts available to export.', 'warning');
      return;
    }

    const headers = ['Broker', 'Client ID', 'Username', 'Status', 'Last Login', 'Developer URL', 'Static IP'];
    const rows = accounts.map(acc => [
      formatBrokerName(acc.broker),
      acc.client_id || '',
      acc.username || '',
      acc.status || '',
      acc.last_login ? formatDateTime(acc.last_login) : '',
      getDeveloperUrl(acc) || '',
      getStaticIp(acc) || ''
    ]);

    const csv = [headers, ...rows]
      .map(row => row.map(toCsvValue).join(','))
      .join('\r\n');

    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    const safeSuffix = sanitizeClientId(filenameSuffix) || 'accounts';
    const timestamp = new Date().toISOString().slice(0, 10);
    link.href = url;
    link.download = `${safeSuffix}-${timestamp}.csv`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    setTimeout(() => URL.revokeObjectURL(url), 0);

    showToast(`Exported ${accounts.length} account${accounts.length === 1 ? '' : 's'}.`, 'success');
  }

  function closeDropdownMenu(dropdown) {
    if (!dropdown) return;
    dropdown.classList.remove('open');
    const toggle = dropdown.querySelector('[data-dropdown-toggle]');
    if (toggle) {
      toggle.setAttribute('aria-expanded', 'false');
    }
  }

  async function reconnectAccountsBulk(accounts) {
    if (!accounts.length) {
      showToast('No accounts selected for reconnection.', 'warning');
      return;
    }

    const label = accounts.length === 1
      ? (accounts[0].client_id || accounts[0].username || 'the selected account')
      : `${accounts.length} selected accounts`;

    if (!confirm(`Attempt to reconnect ${label}?`)) {
      return;
    }

    let successCount = 0;
    const errors = [];

    for (const acc of accounts) {
      if (!acc.client_id) {
        errors.push('Missing client ID for one of the selected accounts.');
        continue;
      }
      try {
        const response = await fetchJson('/api/reconnect-account', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ client_id: acc.client_id })
        });
        if (response.message) {
          successCount += 1;
        } else {
          errors.push(response.error || `Failed to reconnect ${acc.client_id}.`);
        }
      } catch (error) {
        errors.push(error.message || `Failed to reconnect ${acc.client_id}.`);
      }
    }

    if (successCount) {
      showToast(`Reconnected ${successCount} account${successCount === 1 ? '' : 's'}.`, 'success');
      clearSelection();
      setTimeout(() => location.reload(), 250);
    }

    if (errors.length) {
      console.error('Reconnect errors:', errors);
      showToast(`Reconnect completed with ${errors.length} error${errors.length === 1 ? '' : 's'}.`, 'error');
    }
  }

  async function deleteAccountsBulk(accounts) {
    if (!accounts.length) {
      showToast('No accounts selected for deletion.', 'warning');
      return;
    }

    const label = accounts.length === 1
      ? (accounts[0].client_id || accounts[0].username || 'the selected account')
      : `${accounts.length} selected accounts`;

    if (!confirm(`Are you sure you want to delete ${label}? This action cannot be undone.`)) {
      return;
    }

    let successCount = 0;
    const errors = [];

    for (const acc of accounts) {
      if (!acc.client_id) {
        errors.push('Missing client ID for one of the selected accounts.');
        continue;
      }
      try {
        const response = await fetchJson('/api/delete-account', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ client_id: acc.client_id })
        });
        if (response.message) {
          successCount += 1;
        } else {
          errors.push(response.error || `Failed to delete ${acc.client_id}.`);
        }
      } catch (error) {
        errors.push(error.message || `Failed to delete ${acc.client_id}.`);
      }
    }

    if (successCount) {
      showToast(`Deleted ${successCount} account${successCount === 1 ? '' : 's'}.`, 'success');
      clearSelection();
      setTimeout(() => location.reload(), 250);
    }

    if (errors.length) {
      console.error('Delete errors:', errors);
      showToast(`Delete completed with ${errors.length} error${errors.length === 1 ? '' : 's'}.`, 'error');
    }
  }

  async function updateAccountCredentials(account) {
    if (!account || !account.client_id) {
      showToast('Client ID is required to update the account.', 'error');
      return;
    }

    try {
      const response = await fetchJson('/api/update-account', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ client_id: account.client_id })
      });
      showToast(response.message || 'Account updated successfully.');
      clearSelection();
      setTimeout(() => location.reload(), 250);
    } catch (error) {
      showToast(`Failed to update account: ${error.message}`, 'error');
    }
  }

  async function handleBulkMenuAction(action) {
    const dropdown = document.getElementById('more-dropdown');
    closeDropdownMenu(dropdown);

    if (!action) {
      return;
    }

    if (action === 'export-visible') {
      const accounts = getFilteredAccounts();
      if (!accounts.length) {
        showToast('No accounts available to export.', 'warning');
        return;
      }
      exportAccountsData(accounts, 'accounts-visible');
      return;
    }

    const selectedAccounts = getSelectedAccounts();
    if (!selectedAccounts.length) {
      showToast('Please select at least one account.', 'warning');
      return;
    }

    if (action === 'single-reconnect') {
      window.reconnectAccount(selectedAccounts[0].client_id);
      return;
    }

    if (action === 'single-edit') {
      window.editAccount(selectedAccounts[0].client_id);
      return;
    }

    if (action === 'single-delete') {
      window.deleteAccount(selectedAccounts[0].client_id);
      return;
    }

    if (action === 'single-export') {
      const identifier = selectedAccounts[0].client_id || selectedAccounts[0].username || 'account';
      exportAccountsData(selectedAccounts, identifier);
      return;
    }

    if (action === 'single-update') {
      await updateAccountCredentials(selectedAccounts[0]);
      return;
    }

    if (action === 'bulk-reconnect') {
      await reconnectAccountsBulk(selectedAccounts);
      return;
    }

    if (action === 'bulk-delete') {
      await deleteAccountsBulk(selectedAccounts);
      return;
    }

    if (action === 'bulk-export') {
      exportAccountsData(selectedAccounts, `accounts-selected-${selectedAccounts.length}`);
    }
  }

  const addAccountBtn = document.getElementById('add-account-btn');
  if (addAccountBtn) {
    registerListener(addAccountBtn, 'click', () => {
      const section = document.getElementById('add-account-section');
      const isHidden = !section || section.style.display === 'none' || getComputedStyle(section).display === 'none';
      if (isHidden) {
        openAddAccountForm();
        populateBrokerCarousel();
      } else {
        hideBrokerForm();
      }
    });
  }

  const urlParams = new URLSearchParams(window.location.search);
  const openAddAccountParam = urlParams.get('openAddAccount');
  const normalizedParam = (openAddAccountParam || '').toLowerCase();
  const shouldOpenFromParam = openAddAccountParam !== null && !['0', 'false', 'no'].includes(normalizedParam);
  const tokenIdFromUrl = urlParams.get('tokenId') || urlParams.get('token_id');
  const hasPersistedDhanForm = Boolean(getPersistedDhanForm());
  const needsDhanResume = Boolean(tokenIdFromUrl) || hasPersistedDhanForm;
  const shouldOpenAddAccount = shouldOpenFromParam || needsDhanResume;

  if (tokenIdFromUrl) {
    pendingDhanTokenId = tokenIdFromUrl;
    urlParams.delete('tokenId');
    urlParams.delete('token_id');
  }

  if (shouldOpenAddAccount) {
    openAddAccountForm();
    populateBrokerCarousel();

    const section = document.getElementById('add-account-section');
    if (section) {
      window.requestAnimationFrame(() => {
        const sectionTop = section.getBoundingClientRect().top + window.pageYOffset;
        window.scrollTo({ top: Math.max(sectionTop - 16, 0), behavior: 'smooth' });
      });
    }

    if (needsDhanResume) {
      activateBroker('dhan');
    }
  }

  if (shouldOpenFromParam || tokenIdFromUrl) {
    
    urlParams.delete('openAddAccount');
    const newQuery = urlParams.toString();
    const newUrl = `${window.location.pathname}${newQuery ? `?${newQuery}` : ''}${window.location.hash}`;
    window.history.replaceState({}, '', newUrl);
  }

  const cancelAddAccountBtn = document.getElementById('cancel-add-account-btn');
  if (cancelAddAccountBtn) {
    registerListener(cancelAddAccountBtn, 'click', hideBrokerForm);
  }

  const brokerSearchInput = document.getElementById('broker-search');
  if (brokerSearchInput) {
    registerListener(brokerSearchInput, 'input', event => {
      populateBrokerCarousel(event.target.value || '');
    });
  }

  const brokerForm = document.getElementById('broker-credentials-form');
  if (brokerForm) {
    registerListener(brokerForm, 'submit', function(e) {
      e.preventDefault();
      const formData = new FormData(this);
      const data = {};
      for (const [key, value] of formData.entries()) data[key] = value;

      if (Object.prototype.hasOwnProperty.call(data, 'dhan_token_id')) {
        delete data['dhan_token_id'];
      }
  
      const selectedBroker = getSelectedBroker();
      if (!selectedBroker) { showToast('Please select a broker.', 'warning'); return; }
      data['broker'] = selectedBroker;

      if (data['broker'] === 'zerodha') {
        fetchJson('/api/init-zerodha-login', {
          method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(data)
        })
        .then(resp => { if (resp.login_url) window.location.href = resp.login_url; else showToast(resp.error || 'Failed to get login URL for Zerodha.', 'error'); })
        .catch(error => showToast(`Failed to initiate Zerodha login: ${error.message}`, 'error'));
        return;
      }

      if (data['broker'] === 'fyers') {
        fetchJson('/api/init-fyers-login', {
          method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(data)
        })
        .then(resp => { if (resp.login_url) window.location.href = resp.login_url; else showToast(resp.error || 'Failed to get login URL for Fyers.', 'error'); })
        .catch(error => showToast(`Failed to initiate Fyers login: ${error.message}`, 'error'));
        return;
      }

      if (data['broker'] === 'dhan') {
        const hasAccessToken = dhanLoginState && dhanLoginState.accessToken;
        if (!editingAccountId && !hasAccessToken) {
          const controller = dhanConsentController;
          if (controller && typeof controller.start === 'function') {
            showToast('Starting the Dhan consent flow. Complete the approval and we will finish connecting automatically.', 'info');
            controller
              .start({ setPendingSubmit: true })
              .catch(error => console.error('Failed to start Dhan consent during submit:', error));
          } else {
            showToast('Select Dhan and submit again to launch the consent flow automatically.', 'warning');
          }
          return;
        }

        if (dhanLoginState && dhanLoginState.tokenId) {
          data['dhan_token_id'] = dhanLoginState.tokenId;
        }
        if (dhanLoginState && dhanLoginState.payload) {
          data['dhan_login_payload'] = dhanLoginState.payload;
        }
        if (dhanLoginState && dhanLoginState.tokenTime && !data['token_time']) {
          data['token_time'] = dhanLoginState.tokenTime;
        }
        if (dhanLoginState && dhanLoginState.accessToken && !data['access_token']) {
          data['access_token'] = dhanLoginState.accessToken;
        }
        if (dhanLoginState && dhanLoginState.expiry && !data['token_expiry']) {
          data['token_expiry'] = dhanLoginState.expiry;
        }
        if (dhanLoginState && dhanLoginState.dhanClientId) {
          data['client_id'] = dhanLoginState.dhanClientId;
        }
        if (dhanLoginState && dhanLoginState.dhanClientName && !data['client_name']) {
          data['client_name'] = dhanLoginState.dhanClientName;
        }
      }

      const endpoint = editingAccountId ? '/api/update-account' : '/api/add-account';
      if (editingAccountId) data['client_id'] = editingAccountId;

      fetchJson(endpoint, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(data)
      })
      .then(resp => {
        showToast(resp.message || resp.error || 'Operation completed.');
        if (resp.message) {
          if (data['broker'] === 'dhan') {
            clearPersistedDhanForm();
            clearPendingDhanSubmission();
          }
          location.reload();
        }
      })
      .catch(error => showToast(`Failed to save account: ${error.message}`, 'error'));
    });
  }

  document.querySelectorAll('#status-tabs .status-tab').forEach(button => {
    registerListener(button, 'click', e => {
      e.preventDefault();
      statusFilter = button.dataset.status || 'all';
      restoreFilterUI();
      applyFilters();
    });
  });

  const brokerFilterSelect = document.getElementById('broker-filter');
  if (brokerFilterSelect) {
    registerListener(brokerFilterSelect, 'change', e => {
      brokerFilter = e.target.value;
      applyFilters();
    });
  }

  const accountSearchInput = document.getElementById('account-search');
  if (accountSearchInput) {
    registerListener(accountSearchInput, 'input', e => {
      searchFilter = e.target.value;
      applyFilters();
    });
  }

  const accountsTableBody = document.getElementById('accounts-table-body');
  if (accountsTableBody) {
    registerListener(accountsTableBody, 'change', event => {
      const checkbox = event.target.closest('.account-select');
      if (!checkbox) return;
      const clientId = checkbox.dataset.clientId;
      if (!clientId) return;
      if (checkbox.checked) {
        selectedAccountIds.add(clientId);
      } else {
        selectedAccountIds.delete(clientId);
      }
      updateSelectionUI();
    });

    registerListener(accountsTableBody, 'click', event => {
      const actionButton = event.target.closest('[data-action]');
      if (!actionButton) return;
      const row = actionButton.closest('tr');
      if (!row) return;
      const clientId = row.dataset.clientId;
      const account = getAccountByRowId(clientId);
      if (!account) return;

      const action = actionButton.dataset.action;
      if (action === 'copy-url' || action === 'copy-ip') {
        const requires = actionButton.dataset.requires || (action === 'copy-url' ? 'url' : 'ip');
        const value = action === 'copy-url' ? getDeveloperUrl(account) : getStaticIp(account);
        if (!value) {
          showToast(`No ${requires.toUpperCase()} available to copy.`, 'warning');
          return;
        }
        copyToClipboard(value, `${requires.toUpperCase()} copied to clipboard.`);
        const dropdown = actionButton.closest('.dropdown');
        if (dropdown) dropdown.classList.remove('open');
        return;
      }

      if (action === 'reconnect') {
        window.reconnectAccount(account.client_id);
        return;
      }

      if (action === 'edit') {
        window.editAccount(account.client_id);
        const dropdown = actionButton.closest('.dropdown');
        if (dropdown) dropdown.classList.remove('open');
        return;
      }

      if (action === 'refresh-balance') {
        if (!account.client_id) {
          showToast('Cannot refresh balance: missing client ID.', 'warning');
          return;
        }

        const previousTitle = actionButton.getAttribute('title');
        const previousAriaLabel = actionButton.getAttribute('aria-label');
        actionButton.disabled = true;
        actionButton.classList.add('is-loading');
        actionButton.setAttribute('aria-label', 'Refreshing balance…');
        actionButton.setAttribute('title', 'Refreshing balance…');

        refreshBalanceForAccount(account, { cacheOnly: false })
          .then(result => {
            if (!isActive) return;
            if (result) {
              const balanceField = row.querySelector('[data-field="balance"]');
              if (balanceField) {
                balanceField.textContent = formatBalance(account.opening_balance);
              }
              updateAccountCard();
              updateCounts();
              showToast('Balance refreshed successfully.');
            }
          })
          .catch(error => {
            if (!isActive) return;
            const message = error && error.message ? error.message : 'Unable to refresh balance.';
            showToast(`Failed to refresh balance: ${message}`, 'error');
          })
          .finally(() => {
            actionButton.disabled = false;
            actionButton.classList.remove('is-loading');
            if (previousTitle !== null) {
              actionButton.setAttribute('title', previousTitle);
            } else {
              actionButton.removeAttribute('title');
            }
            if (previousAriaLabel !== null) {
              actionButton.setAttribute('aria-label', previousAriaLabel);
            } else {
              actionButton.removeAttribute('aria-label');
            }
            const dropdown = actionButton.closest('.dropdown');
            if (dropdown) dropdown.classList.remove('open');
          });
        return;
      }

      if (action === 'delete') {
        window.deleteAccount(account.client_id);
        const dropdown = actionButton.closest('.dropdown');
        if (dropdown) dropdown.classList.remove('open');
      }
    });
  }

  const selectAllCheckbox = document.getElementById('select-all-accounts');
  if (selectAllCheckbox) {
    registerListener(selectAllCheckbox, 'change', event => {
      const shouldSelectAll = event.target.checked || event.target.indeterminate;
      const filteredAccounts = getFilteredAccounts();
      if (shouldSelectAll) {
        filteredAccounts.forEach(acc => {
          const index = allAccounts.indexOf(acc);
          const rowId = getAccountRowId(acc, index >= 0 ? index : 0);
          selectedAccountIds.add(rowId);
        });
      } else {
        filteredAccounts.forEach(acc => {
          const index = allAccounts.indexOf(acc);
          const rowId = getAccountRowId(acc, index >= 0 ? index : 0);
          selectedAccountIds.delete(rowId);
        });
      }
      updateSelectionUI();
    });
  }

  const bulkActionsDropdown = document.getElementById('more-dropdown');
  if (bulkActionsDropdown) {
    registerListener(bulkActionsDropdown, 'click', event => {
      const actionButton = event.target.closest('[data-bulk-action]');
      if (!actionButton) return;
      event.preventDefault();
      handleBulkMenuAction(actionButton.dataset.bulkAction)
        .catch(error => {
          console.error('Bulk action failed:', error);
          showToast(`Action failed: ${error.message || error}`, 'error');
        });
    });
  }

  updateBulkActionsMenu();

  registerListener(document, 'click', event => {
    const toggle = event.target.closest('[data-dropdown-toggle]');
    if (toggle) {
      event.preventDefault();
      const targetId = toggle.dataset.dropdownToggle;
      const dropdown = document.getElementById(targetId);
      if (!dropdown) return;
      const isOpen = dropdown.classList.contains('open');
      document.querySelectorAll('.dropdown.open').forEach(d => {
        if (d !== dropdown) {
          d.classList.remove('open');
          const btn = d.querySelector('[data-dropdown-toggle]');
          if (btn) btn.setAttribute('aria-expanded', 'false');
        }
      });
      dropdown.classList.toggle('open', !isOpen);
      toggle.setAttribute('aria-expanded', String(!isOpen));
      return;
    }

    if (!event.target.closest('.dropdown')) {
      document.querySelectorAll('.dropdown.open').forEach(d => {
        d.classList.remove('open');
        const btn = d.querySelector('[data-dropdown-toggle]');
        if (btn) btn.setAttribute('aria-expanded', 'false');
      });
    }
  });

  const exportButton = document.querySelector('[data-action="export-accounts"]');
  if (exportButton) {
    registerListener(exportButton, 'click', () => {
      showToast('Export functionality is coming soon.', 'info');
      const dropdown = exportButton.closest('.dropdown');
      if (dropdown) dropdown.classList.remove('open');
    });
  }

  window.deleteAccount = function(cid) {
    if (!confirm('Are you sure you want to delete account ' + cid + '? This action cannot be undone.')) return;
    fetchJson('/api/delete-account', {
      method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ client_id: cid })
    })
    .then(resp => { showToast(resp.message || resp.error || 'Unknown error during deletion.'); if (resp.message) location.reload(); })
    .catch(error => showToast(`Failed to delete account: ${error.message}`, 'error'));
  };

  window.editAccount = function(cid) {
    const acc = allAccounts.find(a => a.client_id === cid);
    if (!acc) { showToast('Account not found for editing.', 'error'); return; }
    editingAccountId = cid;
    openAddAccountForm();
    const section = document.getElementById('add-account-section');
    if (section) {
      const sectionRect = section.getBoundingClientRect();
      const targetOffset = sectionRect.top + window.pageYOffset;
      window.requestAnimationFrame(() => {
        window.scrollTo({ top: targetOffset - 16, behavior: 'smooth' });
      });
    }

    document.querySelectorAll('.broker-card').forEach(i => i.classList.remove('active'));
    const item = document.querySelector(`.broker-card[data-broker="${acc.broker}"]`);
    if (item) { item.classList.add('active'); showBrokerForm(acc.broker); }

    setTimeout(() => {
      const form = document.getElementById('broker-credentials-form');
      if (!form) return;
      const usernameInput = form.querySelector('input[name="username"]');
      if (usernameInput) usernameInput.value = acc.username || '';
      Object.entries(acc.credentials || {}).forEach(([k, v]) => {
        const inp = form.querySelector(`input[name="${k}"]`);
        if (inp) {
          inp.value = v;
          if (k === 'client_id') {
            inp.readOnly = true;
            inp.classList.add('bg-light');
            inp.dispatchEvent(new Event('input', { bubbles: true }));
          }
        }
      });
      const submitBtn = document.getElementById('submit-account-btn');
      if (submitBtn) submitBtn.textContent = 'Update Account';
      const resultDiv = document.getElementById('cred-check-result');
      if (resultDiv) resultDiv.innerHTML = '<span class="text-info small">Modify credentials and click Update.</span>';
    }, 100);
  };

  window.reconnectAccount = function(cid) {
    if (!confirm('Attempt to reconnect account ' + cid + '?')) return;
    fetchJson('/api/reconnect-account', {
      method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ client_id: cid })
    })
    .then(resp => { showToast(resp.message || resp.error || 'Unknown error during reconnection.'); if (resp.message) location.reload(); })
    .catch(error => showToast(`Failed to reconnect account: ${error.message}`, 'error'));
  };

  const accountsFetchController = new AbortController();
  const unregisterAccountsController = registerAbortController(accountsFetchController);

  fetchJson('/api/accounts?cache_only=1', { signal: accountsFetchController.signal })
    .then(data => {

      const newAccounts = Array.isArray(data.accounts) ? data.accounts : [];
      const newSignature = computeAccountsSignature(newAccounts);
      const previousSignature = state.cachedAccounts ? state.cachedAccounts.signature : null;
      const hasChanged = !state.cachedAccounts || previousSignature !== newSignature;

      const newCache = createAccountsCache(newAccounts, newSignature);
      state.cachedAccounts = newCache;
      allAccounts = cloneAccountsList(newCache.accounts);
      pruneAutoLoginResults();

      if (hasChanged) {
        populateBrokerCarousel();
        renderAccounts(allAccounts);
        populateBrokerFilter();
        restoreFilterUI();
        updateCounts();
        applyFilters();
      }

      const runAutoLoginChecks = () => {
        let autoLoginStateChanged = false;
        allAccounts.forEach(acc => {
          const isConnected = (acc.status || '').toLowerCase() === 'connected';
          if (isConnected) {
            if (!autoLoginResults[acc.client_id] || autoLoginResults[acc.client_id].status !== 'success') {
              autoLoginResults[acc.client_id] = { status: 'success' };
              autoLoginStateChanged = true;
            }
            return;
          }

          attemptAutoLoginForAccount(acc)
            .then(() => {
              if (!isActive) return;
              updateCounts();
              updateAccountCard();
            })
            .catch(() => {
              if (!isActive) return;
              updateCounts();
              updateAccountCard();
            });
        });
        if (autoLoginStateChanged) {
          persistAutoLoginState();
        }
      };

      if ('requestIdleCallback' in window) {
        window.requestIdleCallback(runAutoLoginChecks, { timeout: 1500 });
      } else {
        window.setTimeout(runAutoLoginChecks, 0);
      }
    })
    .catch(error => {
      if (!isActive || accountsFetchController.signal.aborted) {
        return;
      }
      showToast(`Failed to load accounts: ${error.message}`, 'error');
    })
    .finally(() => {
      unregisterAccountsController();
    });
};
</script>
{% endblock %}
